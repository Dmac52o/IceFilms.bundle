import os
import tempfile
import urllib, urllib2, urlparse, cgi
import time
import os
from threading import Thread

def NormalizeURL(url):

	return url
	
def MetadataObjectForURL(url):

	return VideoClipObject(title = 'PreBuffer Redirect Page')
	
def MediaObjectsForURL(url):
	
	# Breakdown URL.
	urlParts = urlparse.urlparse(url.replace("prebuffer://","http://"))
	qs = cgi.parse_qs(urlParts.query)
		
	mediaObject = MediaObject(
		parts = [ 
			PartObject(key=Callback(PlayVideo,url=url)) 
		] 
	)

	if ('bitrate' in qs and len(qs['bitrate']) == 1):
		mediaObject.bitrate = int(qs['bitrate'][0])
		
	if ('aspectRatio' in qs and len(qs['aspectRatio']) == 1):
		mediaObject.aspect_ratio = str(qs['aspectRatio'][0])

	if ('videoResolution' in qs and len(qs['videoResolution']) == 1):
		try:
			mediaObject.video_resolution = int(qs['videoResolution'][0])
		except:
			pass
			
	if (mediaObject.video_resolution is None and 'height' in qs and len(qs['height']) == 1):
		try:
			mediaObject.video_resolution = int(qs['height'][0])
		except:
			pass
			
	if ('duration' in qs and len(qs['duration']) == 1):
		mediaObject.duration = int(qs['duration'][0])
		
	if ('videoCodec' in qs and len(qs['videoCodec']) == 1):
		if qs['videoCodec'][0] == 'h264':
			mediaObject.video_codec = VideoCodec.H264
			
	if ('audioCodec' in qs and len(qs['audioCodec']) == 1):
		if qs['audioCodec'][0] == 'aac':
			mediaObject.audio_codec = AudioCodec.AAC
		elif qs['audioCodec'][0] == 'mp3':
			mediaObject.audio_codec = AudioCodec.MP3
		
	if ('container' in qs and len(qs['container']) == 1):
		if qs['container'][0] == 'mov':
			mediaObject.container = Container.MOV

	return [mediaObject]
	
@indirect
def PlayVideo(url):
	
	# Welcome to crazy town....
	#
	# Plex doesn't handle local files if they're not in a user library. So, temporarily add 
	# the file to play to one...
	#
	#Â There supposedly is a way to stream any file off the local file system (Stream.LocalFile 
	# from StreamKit), but that's currently broken and I doubt that it'll get fixed. Serving
	# the file via the Plugin's tornado Web Server instance using R() leads to very poor 
	# performance as does spinning up our own tornado instance and serving from there.
	#
	# Annoyingly enough, it all could be so easy...
	#
	# The desktop clients could easily be supported when running on the same machine as the
	# server by returning a file:// URL. However, this won't work when they're running on a different
	# machine. Remaining clients (which will ask for the file to be transcoded since we don't know
	# anything about the buffered item), do support a file:// URL but only if it doesn't contain
	# space, which won't be the case for us due to where we save the buffered items.
	
	# Breakdown URL.
	urlParts = urlparse.urlparse(url.replace("prebuffer://","http://"))
	pathParts = urlParts.path.split("/")
	
	Log(pathParts)
	# Extract out videoPrefix, encoded pre-buffer key / url and part index.
	videoPrefix = "/".join(pathParts[0:-2])
	encodedKey = pathParts[-2]
	partIndex = pathParts[-1]
	
	# Ask plugin to add video to a library and give us the part url back.
	# This could be done directly in here, but this way allows for code to be re-used
	# across this service and the plugin.
	request = urllib2.Request(
		"http://127.0.0.1:32400%s/prebuffer/playback/%s/%s" % (videoPrefix, encodedKey, partIndex)
	)
	response = urllib2.urlopen(request)
	fileInfo = JSON.ObjectFromString(response.read())
	
	# Schedule for the library to be removed.
	CleanupAgent(videoPrefix, url, fileInfo['filePath']).start()
	
	if ('fileURL' in fileInfo):
		return ObjectContainer(
			objects = [
				VideoClipObject(
					items = [
						MediaObject(
							parts = [
								PartObject(key=fileInfo['fileURL']),
							],
						)
					]
				)
			]
		)
	

class CleanupAgent(Thread):

	def __init__(self, videoPrefix, url, path):
	
		Thread.__init__(self)
		self.videoPrefix = videoPrefix
		self.url = url
		self.path = path
		
	def run(self):
	
		Log("*** Spending 30 secs checking whether item ends up in seesion")
		cnt = 0
		while (cnt < 30 and not self.isInSession(self.url)):
			time.sleep(1)
			cnt = cnt + 1
			
		if self.isInSession(self.url):
		
			Log("*** Player in session!")
			while self.isInSession(self.url):
					
				#Log("*** Sleepng till next in session check")
				time.sleep(1)
				
			Log("*** Player no longer in session")
	
			# Ask plugin to remove path from Lib.
			Log("*** Deleting %s from lib" % self.path)
			request = urllib2.Request(
				"http://127.0.0.1:32400%s/prebuffer/delPathFromLib/%s" % (self.videoPrefix, String.Encode(self.path))
			)
			
			try:
				response = urllib2.urlopen(request)
			except Exception, ex:
				Log.Exception(ex)
		
			Log("*** Done")
			
		else:
			Log("*** Player not in session. Cleanup will need to be done base on ClientID. Terminating.")
		
	def isInSession(self, url):
	
		#Log("*** Checking if item is in session")
		
		try:
			# Monitor /status/sessions.
			request = urllib2.Request("http://127.0.0.1:32400/status/sessions")
			
			# FIXME: This may throw a 404...
			response = urllib2.urlopen(request)
			
			# Look for the one and only media item in there with our name.
			content = response.read()
			elem = XML.ElementFromString(content)
			
			partElems = elem.xpath("//Video[@url='%s']" % url)
		
			return len(partElems) > 0
			
		except Exception, ex:
			
			Log.Exception("*** Error whilst checking item is in session")
			